package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"log"
	"time"

	"github.com/mvpratt/nodewatcher/internal/db"
	"github.com/mvpratt/nodewatcher/internal/graph/model"
)

// CreatedAt is the resolver for the created_at field.
func (r *multiChannelBackupResolver) CreatedAt(ctx context.Context, obj *model.MultiChannelBackup) (string, error) {
	return obj.CreatedAt.Format(time.RFC850), nil
}

// CreateNode is the resolver for the createNode field.
func (r *mutationResolver) CreateNode(ctx context.Context, input model.NewNode) (*model.Node, error) {
	node := &model.Node{
		ID:       int64(input.ID),
		URL:      input.URL,
		Alias:    input.Alias,
		Pubkey:   input.Pubkey,
		Macaroon: input.Macaroon,
		TLSCert:  input.TLSCert,
		UserID:   int64(input.UserID),
	}

	dbNode := &db.Node{
		ID:       0,
		URL:      input.URL,
		Alias:    input.Alias,
		Pubkey:   input.Pubkey,
		Macaroon: input.Macaroon,
		TLSCert:  input.TLSCert,
		UserID:   int64(input.UserID),
	}
	err := db.InsertNode(dbNode)
	if err != nil {
		log.Print(err.Error())
	}
	return node, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	user := &model.User{
		ID:          int64(input.ID),
		Email:       input.Email,
		Password:    input.Password,
		PhoneNumber: input.PhoneNumber,
		SmsEnabled:  input.SmsEnabled,
	}

	dbUser := &db.User{
		ID:          0,
		Email:       input.Email,
		Password:    input.Password,
		PhoneNumber: input.PhoneNumber,
		SmsEnabled:  input.SmsEnabled,
	}
	err := db.InsertUser(dbUser)
	if err != nil {
		log.Print(err.Error())
	}
	return user, nil
}

// Nodes is the resolver for the nodes field.
func (r *queryResolver) Nodes(ctx context.Context) ([]*model.Node, error) {
	nodes, err := db.FindAllNodes(ctx)
	if err != nil {
		return nil, err
	}

	var graphNodes []*model.Node

	var g *model.Node
	for _, node := range nodes {
		g = &model.Node{
			ID:       int64(node.ID),
			URL:      node.URL,
			Alias:    node.Alias,
			Pubkey:   node.Pubkey,
			Macaroon: node.Macaroon,
		}
		graphNodes = append(graphNodes, g)
	}
	return graphNodes, nil
}

// Channels is the resolver for the channels field.
func (r *queryResolver) Channels(ctx context.Context) ([]*model.Channel, error) {
	channels, err := db.FindAllChannels(ctx)
	if err != nil {
		return nil, err
	}

	var graphChannels []*model.Channel

	var g *model.Channel
	for _, channel := range channels {
		g = &model.Channel{
			ID:          channel.ID,
			FundingTxid: channel.FundingTxid,
			OutputIndex: channel.OutputIndex,
			NodeID:      channel.NodeID,
		}
		graphChannels = append(graphChannels, g)
	}
	return graphChannels, nil
}

// MultiChannelBackups is the resolver for the multi_channel_backups field.
func (r *queryResolver) MultiChannelBackups(ctx context.Context) ([]*model.MultiChannelBackup, error) {
	channels, err := db.FindAllMultiChannelBackups(ctx)
	if err != nil {
		return nil, err
	}

	var graphChannels []*model.MultiChannelBackup

	var g *model.MultiChannelBackup
	for _, channel := range channels {
		g = &model.MultiChannelBackup{
			ID:        channel.ID,
			CreatedAt: channel.CreatedAt,
			Backup:    channel.Backup,
			NodeID:    channel.NodeID,
		}
		graphChannels = append(graphChannels, g)
	}
	return graphChannels, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	users, err := db.FindAllUsers(ctx)
	if err != nil {
		return nil, err
	}

	var graphUsers []*model.User

	var g *model.User
	for _, user := range users {
		g = &model.User{
			ID:          int64(user.ID),
			Email:       user.Email,
			Password:    user.Password,
			PhoneNumber: user.PhoneNumber,
			SmsEnabled:  user.SmsEnabled,
		}
		graphUsers = append(graphUsers, g)
	}
	return graphUsers, nil
}

// SmsNotifyTime is the resolver for the sms_notify_time field.
func (r *userResolver) SmsNotifyTime(ctx context.Context, obj *model.User) (string, error) {
	return obj.SmsNotifyTime.Format(time.RFC850), nil
}

// SmsLastSent is the resolver for the sms_last_sent field.
func (r *userResolver) SmsLastSent(ctx context.Context, obj *model.User) (string, error) {
	return obj.SmsLastSent.Format(time.RFC850), nil
}

// MultiChannelBackup returns MultiChannelBackupResolver implementation.
func (r *Resolver) MultiChannelBackup() MultiChannelBackupResolver {
	return &multiChannelBackupResolver{r}
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type multiChannelBackupResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
